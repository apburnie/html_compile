<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Explanation of html_compile syntax</title><meta name="description" content="Describes how html_compile syntax works" /><style>code {background: #DEDEDE;} section {border : 1px solid black; width: min(100rem, 90vw); border-radius: 5px; padding: 1rem; margin-bottom: 1rem;}</style></head><body><h1>Guide to html_compile&rsquo;s macros</h1><p>html_compile provides macros that enable a more concise representation of HTML data. This guide explains how these macros work through examples</p><section><h2>Creating a Text Element</h2><code>html!(div (style=&ldquo;color: blue;&rdquo; class=&ldquo;Hello&rdquo;) &ldquo;Hello World&rdquo;)</code><p>Will create the following string of HTML that consists of a div with a style attribute that renders the text blue, a class attribute set to &ldquo;Hello&rdquo; and text set to &ldquo;Hello World&rdquo; as shown below</p><code>&lt;div style=&ldquo;color:blue;&rdquo; class=&ldquo;Hello&rdquo;&gt;Hello World&lt;/div&gt;</code><p>In the browser this renders as</p><div style="color: blue;" class="Hello">Hello World</div><p><span>The first token (here </span><code>div</code><span>) specifies the name of the element</span></p><span>The set of parentheses contains the attributes for the element. The attribute name comes before the &equals; and the attribute value after and is in double quotation marks. Different attributes are separated by whitespace.So in the example the attribute style is used to change the color to blue and the attribute class is used to assign the Hello class.</span><p>The text in double quotation marks at the end specifies the text content &ldquo;Hello World&rdquo;</p><p>The text can also be derived from a variable. In this case surround the variable with curly brackets &lcub;&rcub;</p><div><code>let example_text = &ldquo;Hello World&rdquo;;</code></div><div><code>html!(div (style=&ldquo;color: blue;&rdquo; class=&ldquo;Hello&rdquo;) &lcub;example_text&rcub;)</code></div><p>gives the same result as before</p><div style="color:blue;" class="Hello">Hello World</div></section><section><h2>Creating an Element with No Attributes or Content</h2><p><span>Both </span><code>html!(div)</code><span> and </span><code>html!(div ())</code><span>will create a string of HTML consisting of an empty div with no styling</span><code>&lt;div&gt;&lt;/div&gt;</code></p><p><span>Void elements should not have end tags and this is handled accordingly. For example </span><code>html!(hr)</code><span> will return </span><code>&lt;hr/&gt;</code></p></section><section><h2>Creating Elements that Contain other Elements</h2><code>html!(ul () [el!(li () &ldquo;First Sibling&rdquo;)] [el!(li () &ldquo;Second Sibling&rdquo;)]</code><p>Will create the following string of HTML that consists of an unordered list with two items</p><code>&lt;ul&gt;&lt;li&gt;First Sibling&lt;/li&gt;&lt;li&gt;Second Sibling&lt;/li&gt;&lt;/ul&gt;</code><p>In the browser this renders as</p><ul><li>First Sibling</li><li>Second Sibling</li></ul><p>Each child component is surrounded by square brackets &lsqb;&rsqb; and is inputted into the macro el! which creates the component. Whitespace is used to separate different child components that will be treated as siblings.</p></section><section><h2>Where Child Elements are Specified through a Vector or an Array</h2><div><pre><code>let example_list = [
  el!(li () &ldquo;First Sibling&rdquo;),
  el!(li () &ldquo;Second Sibling&rdquo;)
];</code></pre></div><code>html!(ul () vec[example_list]</code><p>Will create the following string of HTML that consists of an unordered list with two items</p><code>&lt;ul&gt;&lt;li&gt;First Sibling&lt;/li&gt;&lt;li&gt;Second Sibling&lt;/li&gt;&lt;/ul&gt;</code><p>In the browser this renders as</p><ul><li>First Sibling</li><li>Second Sibling</li></ul><p>Inserting the text vec before the square brackets &lsqb;&rsqb; tells the macro to expect a vector or array.</p></section></body></html>